<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Oshiri Stamp Maker Pro</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root {
        --twitch-purple: #9146FF;
        --twitch-bg: #0e0e10;
        --panel-bg: #18181b;
        --border-color: #2f2f35;
    }
    body {
        background-color: var(--twitch-bg);
        color: #efeff1;
        font-family: 'Inter', sans-serif;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        margin: 0;
        padding: 0;
    }

    /* ナビゲーターエリア */
    .navigator-area {
        background: radial-gradient(circle at center, #1f1f23 0%, #0e0e10 100%);
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        padding: 20px;
    }
    
    .nav-content-wrapper {
        position: relative;
        box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        display: block;
        line-height: 0;
    }

    #navVideo, #navImage {
        display: block;
        width: 100%;
        height: 100%;
        pointer-events: none;
        user-select: none;
        object-fit: fill;
    }
    
    #navBox {
        position: absolute;
        border: 2px solid #ff4444;
        background: rgba(255, 68, 68, 0.1);
        z-index: 10;
        cursor: move;
        box-shadow: 0 0 0 4000px rgba(0,0,0,0.5);
    }
    .resize-handle {
        position: absolute;
        width: 14px; height: 14px;
        background: #ff4444;
        border: 2px solid #fff;
        border-radius: 50%;
        z-index: 20;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #handle-se { bottom: -7px; right: -7px; cursor: nwse-resize; }

    /* プレビューオーバーレイ */
    #qualityPreviewImage {
        position: absolute; top: 0; left: 0; 
        width: 100%; height: 100%; 
        object-fit: fill; 
        pointer-events: none; z-index: 15; 
        display: none; opacity: 0.9;
    }
    #previewLoading {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px;
        z-index: 30; font-size: 12px; font-weight: bold; color: #fff;
        display: none; pointer-events: none;
    }

    /* タイムライン */
    .timeline-container {
        position: relative; height: 32px; background: #000;
        border-radius: 4px; cursor: crosshair; overflow: hidden; border: 1px solid #333;
    }
    .timeline-selection {
        position: absolute; top: 0; bottom: 0; background: rgba(145, 70, 255, 0.3);
        border-top: 2px solid var(--twitch-purple); border-bottom: 2px solid var(--twitch-purple);
        cursor: grab;
    }
    .timeline-handle {
        position: absolute; top: 0; bottom: 0; width: 12px;
        cursor: ew-resize; z-index: 20; background: rgba(255,255,255,0.2);
    }
    .handle-left { left: 0; } .handle-right { right: 0; }
    .playhead {
        position: absolute; top: 0; bottom: 0; width: 2px; background: #ff4444;
        z-index: 15; pointer-events: none;
    }

    /* 画像リスト */
    #imageListContainer {
        display: flex;
        gap: 8px;
        overflow-x: auto;
        padding: 8px;
        min-height: 60px;
        align-items: center;
        background-color: #050505;
        border: 1px solid #27272a;
        border-radius: 6px;
    }
    .sortable-item {
        width: 40px; height: 40px; flex-shrink: 0; border-radius: 6px;
        background: #000; border: 2px solid #333; cursor: grab;
        position: relative; overflow: hidden; transition: transform 0.2s, border-color 0.2s;
    }
    .sortable-item:hover { border-color: #666; }
    .sortable-item.dragging { opacity: 0.5; border-color: var(--twitch-purple); cursor: grabbing; }
    .sortable-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    .sortable-index {
        position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.7);
        color: #fff; font-size: 8px; padding: 1px 3px; border-top-left-radius: 4px; pointer-events: none;
    }
    .delete-btn {
        position: absolute; top: 0; right: 0;
        width: 16px; height: 16px;
        background: rgba(0, 0, 0, 0.6); color: #fff;
        font-size: 12px; line-height: 1;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; z-index: 20;
        border-bottom-left-radius: 4px;
        transition: background 0.2s;
    }
    .delete-btn:hover { background: #ff4444; }

    /* トースト */
    .toast {
        position: fixed; bottom: 340px; left: 50%; transform: translateX(-50%) translateY(20px);
        background: #1f1f23; color: #fff; padding: 8px 16px; border-radius: 6px;
        opacity: 0; transition: all 0.3s; z-index: 9999; font-size: 13px; font-weight: 600;
        border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: none;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

    /* UI Parts */
    .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #52525b; }

    input[type=range] { -webkit-appearance: none; background: transparent; }
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%;
        background: #9146FF; cursor: pointer; margin-top: -4px; border: 2px solid #fff;
    }
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 4px; cursor: pointer; background: #3f3f46; border-radius: 2px;
    }
    input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    
    .toggle-checkbox:checked { right: 0; border-color: #9146FF; }
    .toggle-checkbox:checked + .toggle-label { background-color: #9146FF; }
    
    .toggle-checkbox:disabled + .toggle-label { background-color: #333; opacity: 0.5; cursor: not-allowed; }
    .toggle-checkbox:disabled { cursor: not-allowed; border-color: #444; }
</style>
</head>
<body class="flex flex-col h-screen bg-[#09090b]">

<!-- Header -->
    <header class="h-10 border-b border-[#27272a] flex justify-between items-center bg-[#1f1f23] px-4 shrink-0 z-50">
        <h1 class="text-sm font-bold flex items-center gap-2 text-gray-100">
            <svg class="w-5 h-5 text-[#9146FF]" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 13v3c0 4-8 5-9 0-1-6 4-12 9-12s10 6 9 12c-1 5-9 4-9 0" />
            </svg>
            Stamp Maker <span class="text-[10px] bg-[#2d2d31] text-gray-400 px-1.5 py-0.5 rounded ml-1 border border-[#3f3f46]">PRO</span>
        </h1>
        <div id="modeBadge" class="text-[10px] font-mono text-gray-500 bg-[#121214] px-2 py-1 rounded border border-[#27272a]">IDLE</div>
    </header>

    <!-- Initial Upload View -->
    <div id="initialView" class="flex-1 flex flex-col items-center justify-center p-4">
        <label id="mainDropZone" class="w-full max-w-lg h-64 border-2 border-dashed border-[#3f3f46] rounded-xl flex flex-col items-center justify-center cursor-pointer hover:bg-[#18181b] hover:border-[#9146FF] transition-all group">
            <input type="file" id="mainFileInput" accept="video/*, image/*" multiple class="hidden">
            <div class="p-4 rounded-full bg-[#1f1f23] mb-3 group-hover:scale-110 transition duration-300">
                <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
            </div>
            <div class="text-lg font-bold text-gray-200">Drag & Drop</div>
            <div class="text-xs text-gray-500 mt-1">Video or Images</div>
        </label>
    </div>

    <!-- Editor View -->
    <div id="editorView" class="hidden flex-1 flex-col h-full overflow-hidden">
        
        <!-- TOP: Navigator -->
        <div class="flex-1 min-h-0 navigator-area relative group" id="navArea">
            <div class="nav-content-wrapper" id="navContainer">
                <video id="navVideo" muted playsinline></video>
                <img id="navImage" alt="">
                
                <!-- Red Box -->
                <div id="navBox">
                    <div id="handle-se" class="resize-handle"></div>
                    <!-- Quality Preview Overlay -->
                    <img id="qualityPreviewImage">
                    <div id="previewLoading">PREVIEW...</div>
                </div>
            </div>
            
            <div class="absolute top-3 left-4 text-xs font-bold text-white/50 bg-black/30 px-2 py-1 rounded backdrop-blur-sm pointer-events-none">NAVIGATOR</div>
            <div class="absolute bottom-3 right-4 text-[10px] text-white/40 pointer-events-none">Drag box to move • Corner to resize</div>
        </div>

        <!-- BOTTOM: Controls & History (Compact Mode) -->
        <div class="h-auto max-h-[50vh] bg-[#18181b] border-t border-[#27272a] flex shrink-0 divide-x divide-[#27272a]">
            
            <!-- Main Settings (Left) -->
            <div class="flex-1 flex flex-col p-3 gap-2 overflow-y-auto custom-scrollbar">
                
                <!-- 2-Col Layout for Settings -->
                <div class="flex gap-4">
                    
                    <!-- Col 1: Output Settings -->
                    <div class="flex-1 flex flex-col gap-2">
                        <div class="flex items-center justify-between mb-0.5">
                            <div class="flex items-center gap-2">
                                <svg class="w-4 h-4 text-[#9146FF]" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                                <span class="text-xs font-bold text-gray-400">OUTPUT</span>
                            </div>
                            <!-- Twitch Mode Toggle -->
                            <div class="flex items-center gap-1.5 bg-[#0e0e10] px-2 py-0.5 rounded border border-[#333]" title="Limit settings for Twitch emotes">
                                <span class="text-[9px] font-bold text-[#9146FF]">Twitch</span>
                                <div class="relative w-6 h-3">
                                    <input type="checkbox" id="twitchModeToggle" checked class="toggle-checkbox absolute block w-3 h-3 rounded-full bg-white border-2 appearance-none cursor-pointer border-[#333] right-3 transition-all duration-200"/>
                                    <label for="twitchModeToggle" class="toggle-label block overflow-hidden h-3 rounded-full bg-[#333] cursor-pointer"></label>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-[#1f1f23] p-2.5 rounded-xl border border-[#2f2f35] shadow-sm space-y-2">
                            
                            <!-- Size Settings -->
                            <div class="flex items-center gap-2 border-b border-[#2f2f35] pb-2 mb-1">
                                <div class="w-14 shrink-0">
                                    <label class="text-[9px] font-bold text-gray-500 block mb-0.5">SIZE (px)</label>
                                    <input type="number" id="sizeInput" value="112" step="1" min="16" max="112" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded text-center py-1">
                                </div>
                                <div class="flex-1 flex items-end h-full pb-1">
                                    <label class="flex items-center gap-1.5 cursor-pointer select-none opacity-50" id="originalSizeLabel">
                                        <input type="checkbox" id="originalSizeToggle" disabled class="rounded bg-[#0e0e10] border-[#333] text-[#9146FF] focus:ring-0 w-3.5 h-3.5 cursor-pointer">
                                        <span class="text-[9px] font-bold text-gray-400">Original Size</span>
                                    </label>
                                </div>
                            </div>

                            <!-- FPS & Preset -->
                            <div class="flex items-center gap-2">
                                <div class="w-14 shrink-0">
                                    <label class="text-[9px] font-bold text-gray-500 block mb-0.5">FPS</label>
                                    <input type="number" id="fpsInput" value="30" step="0.1" min="1" max="60" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded text-center py-1">
                                </div>
                                <div class="flex-1">
                                    <label class="text-[9px] font-bold text-gray-500 block mb-0.5">PRESET</label>
                                    <select id="fpsSelect" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded px-2 py-1">
                                        <option value="60">60 FPS</option>
                                        <option value="30" selected>30 FPS</option>
                                        <option value="20">20 FPS</option>
                                        <option value="15">15 FPS</option>
                                        <option value="10">10 FPS</option>
                                        <option value="5">5 FPS</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Duration & Frames -->
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="text-[9px] font-bold text-gray-500 block mb-0.5">SEC</label>
                                    <input type="number" id="durationInput" value="1.0" step="0.1" min="0.1" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded text-center py-1">
                                </div>
                                <div>
                                    <label class="text-[9px] font-bold text-gray-500 block mb-0.5">FRAMES</label>
                                    <input type="number" id="framesInput" value="30" step="1" min="1" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded text-center py-1">
                                </div>
                            </div>
                            
                            <!-- Extend Frames Toggle -->
                            <div id="extendFramesContainer" class="flex items-center justify-between bg-[#0e0e10] p-1.5 rounded border border-[#333]">
                                <span class="text-[9px] text-gray-400 font-bold ml-1">Stretch Frames</span>
                                <div class="relative w-7 h-3.5">
                                    <input type="checkbox" id="extendFramesToggle" checked class="toggle-checkbox absolute block w-3.5 h-3.5 rounded-full bg-white border-2 appearance-none cursor-pointer border-[#333] right-3.5 transition-all duration-200"/>
                                    <label for="extendFramesToggle" class="toggle-label block overflow-hidden h-3.5 rounded-full bg-[#333] cursor-pointer"></label>
                                </div>
                            </div>
                            
                            <!-- Quality -->
                            <div>
                                <label class="text-[9px] font-bold text-gray-500 block mb-0.5">QUALITY</label>
                                <select id="qualitySelect" class="w-full bg-[#0e0e10] border border-[#333] text-gray-200 text-xs rounded px-2 py-1">
                                    <option value="1" selected>High</option>
                                    <option value="10">Normal</option>
                                    <option value="20">Low</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Col 2: Image Adjustment -->
                    <div class="flex-1 flex flex-col gap-2">
                        <div class="flex items-center justify-between mb-0.5">
                            <div class="flex items-center gap-2">
                                <svg class="w-4 h-4 text-[#9146FF]" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                                <span class="text-xs font-bold text-gray-400">ADJUSTMENT</span>
                            </div>
                            <!-- Free Aspect Toggle -->
                            <div class="flex items-center gap-1.5" title="Allow non-square crop">
                                <span class="text-[9px] font-bold text-gray-500">Free Aspect</span>
                                <div class="relative w-6 h-3">
                                    <input type="checkbox" id="freeAspectToggle" disabled class="toggle-checkbox absolute block w-3 h-3 rounded-full bg-white border-2 appearance-none cursor-pointer border-[#333] right-3 transition-all duration-200"/>
                                    <label for="freeAspectToggle" class="toggle-label block overflow-hidden h-3 rounded-full bg-[#333] cursor-pointer"></label>
                                </div>
                            </div>
                        </div>

                        <div class="bg-[#1f1f23] p-2.5 rounded-xl border border-[#2f2f35] shadow-sm space-y-1.5">
                            <div class="flex items-center gap-2">
                                <span class="text-[9px] font-bold text-gray-500 w-8">BRT</span>
                                <input type="range" id="brightnessSlider" min="0" max="200" value="100" class="flex-1">
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-[9px] font-bold text-gray-500 w-8">CON</span>
                                <input type="range" id="contrastSlider" min="0" max="200" value="100" class="flex-1">
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-[9px] font-bold text-gray-500 w-8">SAT</span>
                                <input type="range" id="saturateSlider" min="0" max="200" value="100" class="flex-1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Timeline / Image List -->
                <div class="mt-1">
                    <div id="videoTimelineArea" class="hidden">
                        <div class="flex justify-between text-[10px] text-gray-500 mb-0.5">
                            <span>TIMELINE</span>
                            <span id="timeDisplay" class="text-white font-mono">0.0s - 1.0s</span>
                        </div>
                        <div class="timeline-container" id="timeline">
                            <div id="playhead" class="playhead"></div>
                            <div id="timelineSelection" class="timeline-selection" style="left: 0%; width: 20%;">
                                <div class="timeline-handle handle-left" data-handle="left"></div>
                                <div class="timeline-handle handle-right" data-handle="right"></div>
                            </div>
                        </div>
                        <div class="text-right"><span class="text-[9px] text-[#9146FF]" id="maxDurationDisplay">Max 1.0s</span></div>
                    </div>

                    <div id="imageListArea" class="hidden">
                        <div class="flex justify-between text-[10px] text-gray-500 mb-0.5">
                            <span>ORDER</span>
                            <span id="imageCountDisplay" class="text-white">0 Images</span>
                        </div>
                        <div id="imageListContainer" class="custom-scrollbar"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="flex gap-3 mt-auto pt-1">
                    <button id="playLoopBtn" class="flex-1 bg-[#27272a] hover:bg-[#333] text-white text-xs font-bold py-2 rounded border border-[#3f3f46] flex items-center justify-center gap-2">
                        <svg id="playIcon" class="w-4 h-4 text-gray-400" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg> PREVIEW LOOP
                    </button>
                    <button id="generateBtn" class="flex-[2] bg-[#9146FF] hover:bg-[#772ce8] text-white text-xs font-bold py-2 rounded shadow-lg flex items-center justify-center gap-2">
                        CREATE STAMP
                    </button>
                </div>
                <div id="progressContainer" class="hidden h-1 bg-[#0e0e10] rounded-full overflow-hidden mt-1">
                    <div id="progressBar" class="bg-[#9146FF] h-full w-0 transition-all duration-300"></div>
                </div>
            </div>

            <!-- Col 3: History & Upload (Right) -->
            <div class="w-[240px] flex flex-col shrink-0 bg-[#121214]">
                <div class="p-2 border-b border-[#27272a] flex justify-between items-center bg-[#18181b]">
                    <span class="text-[10px] font-bold text-gray-400 tracking-wider">HISTORY</span>
                    <button class="text-[10px] text-gray-500 hover:text-white" onclick="document.getElementById('resultList').innerHTML=''">CLEAR</button>
                </div>
                
                <div id="resultList" class="flex-1 overflow-y-auto p-2 space-y-2 custom-scrollbar">
                    <div class="text-center mt-10 text-[10px] text-gray-600">No stamps</div>
                </div>

                <div class="p-2 border-t border-[#27272a] bg-[#18181b]">
                    <label id="miniDropZone" class="block w-full h-10 border border-dashed border-[#444] rounded hover:border-[#9146FF] hover:bg-[#27272a] cursor-pointer flex flex-col items-center justify-center group">
                        <input type="file" id="miniUploadInput" accept="video/*, image/*" multiple class="hidden">
                        <span class="text-[10px] text-gray-400 group-hover:text-white font-bold flex gap-1"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg> Add / Replace</span>
                    </label>
                </div>
            </div>

        </div>
    </div>

    <div id="toast" class="toast"></div>

    <!-- Hidden Source Elements -->
    <video id="sourceVideo" class="hidden" muted playsinline></video>
    <img id="sourceImage" class="hidden">

<script>
    // --- Init Worker ---
    let workerBlobURL = '';
    (async function initWorker() {
        try {
            const res = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
            const code = await res.text();
            workerBlobURL = URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));
        } catch(e) { console.error(e); }
    })();

    // --- DOM Elements ---
    const els = {
        initialView: document.getElementById('initialView'),
        editorView: document.getElementById('editorView'),
        mainDropZone: document.getElementById('mainDropZone'),
        mainFileInput: document.getElementById('mainFileInput'),
        miniUploadInput: document.getElementById('miniUploadInput'),
        miniDropZone: document.getElementById('miniDropZone'),
        
        navArea: document.getElementById('navArea'),
        navVideo: document.getElementById('navVideo'),
        navImage: document.getElementById('navImage'),
        navContainer: document.getElementById('navContainer'),
        navBox: document.getElementById('navBox'),
        navResizeHandle: document.getElementById('handle-se'),
        
        sourceVideo: document.getElementById('sourceVideo'),
        sourceImage: document.getElementById('sourceImage'),
        
        videoTimelineArea: document.getElementById('videoTimelineArea'),
        timeline: document.getElementById('timeline'),
        timelineSelection: document.getElementById('timelineSelection'),
        playhead: document.getElementById('playhead'),
        timeDisplay: document.getElementById('timeDisplay'),
        maxDurationDisplay: document.getElementById('maxDurationDisplay'),
        
        imageListArea: document.getElementById('imageListArea'),
        imageListContainer: document.getElementById('imageListContainer'),
        imageCountDisplay: document.getElementById('imageCountDisplay'),
        extendFramesContainer: document.getElementById('extendFramesContainer'),
        extendFramesToggle: document.getElementById('extendFramesToggle'),
        
        // New Controls
        twitchModeToggle: document.getElementById('twitchModeToggle'),
        sizeInput: document.getElementById('sizeInput'),
        originalSizeToggle: document.getElementById('originalSizeToggle'),
        originalSizeLabel: document.getElementById('originalSizeLabel'),
        freeAspectToggle: document.getElementById('freeAspectToggle'),
        
        fpsInput: document.getElementById('fpsInput'),
        fpsSelect: document.getElementById('fpsSelect'),
        durationInput: document.getElementById('durationInput'),
        framesInput: document.getElementById('framesInput'),
        qualitySelect: document.getElementById('qualitySelect'),
        brightnessSlider: document.getElementById('brightnessSlider'),
        contrastSlider: document.getElementById('contrastSlider'),
        saturateSlider: document.getElementById('saturateSlider'),
        
        playLoopBtn: document.getElementById('playLoopBtn'),
        playIcon: document.getElementById('playIcon'),
        generateBtn: document.getElementById('generateBtn'),
        progressContainer: document.getElementById('progressContainer'),
        progressBar: document.getElementById('progressBar'),
        resultList: document.getElementById('resultList'),
        modeBadge: document.getElementById('modeBadge'),
        
        qualityPreviewImage: document.getElementById('qualityPreviewImage'),
        previewLoading: document.getElementById('previewLoading')
    };

    const CONFIG = { MAX_FRAMES: 60, DEFAULT_CROP_SIZE: 300 };
    
    let state = {
        mode: 'video', fps: 30, maxDuration: 1.0,
        cropW: 300, cropH: 300, posX: 0, posY: 0,
        videoDuration: 0, startTime: 0, endTime: 1.0,
        mediaWidth: 0, mediaHeight: 0,
        images: [],
        totalFrames: 30,
        extendFrames: true,
        filters: { brightness: 100, contrast: 100, saturate: 100 },
        isDraggingNav: false, isResizingNav: false, isDraggingTimeline: false,
        dragStart: { x:0, y:0, posX:0, posY:0, width:0, scale:0, startPct:0, endPct:0 },
        isPlayingLoop: false, animationFrameId: null, loopStartTime: null,
        
        // New States
        twitchMode: true,
        useOriginalSize: false,
        freeAspect: false
    };

    // --- Event Listeners ---
    els.mainFileInput.addEventListener('change', e => handleFiles(e.target.files));
    els.miniUploadInput.addEventListener('change', e => handleMiniUpload(e.target.files));
    
    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); };
    window.addEventListener('dragover', handleDrag); window.addEventListener('drop', handleDrag);
    
    els.mainDropZone.addEventListener('drop', e => { handleFiles(e.dataTransfer.files); });
    
    // Mini Drop Zone
    els.miniDropZone.addEventListener('dragover', e => { 
        e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; 
        els.miniDropZone.classList.add('border-[#9146FF]', 'bg-[#27272a]'); 
    });
    els.miniDropZone.addEventListener('dragleave', e => { 
        els.miniDropZone.classList.remove('border-[#9146FF]', 'bg-[#27272a]'); 
    });
    els.miniDropZone.addEventListener('drop', e => {
        e.preventDefault();
        els.miniDropZone.classList.remove('border-[#9146FF]', 'bg-[#27272a]');
        handleMiniUpload(e.dataTransfer.files);
    });

    // Extend Frames Toggle
    els.extendFramesToggle.addEventListener('change', e => {
        state.extendFrames = e.target.checked;
        if (!state.extendFrames && state.mode === 'image') {
            state.totalFrames = Math.max(1, state.images.length);
            els.framesInput.value = state.totalFrames;
            els.framesInput.disabled = true;
            els.framesInput.classList.add('opacity-50');
        } else {
            els.framesInput.disabled = false;
            els.framesInput.classList.remove('opacity-50');
        }
        updateConfig('frames');
    });

    // Twitch Mode: Input Enforcement (Force Limit)
    els.sizeInput.addEventListener('input', function() {
        if (state.twitchMode) {
            const val = parseInt(this.value);
            if (val > 112) this.value = 112;
        }
    });

    els.fpsInput.addEventListener('input', function() {
        if (state.twitchMode) {
            const val = parseFloat(this.value);
            if (val > 60) this.value = 60;
        }
    });

    // New: Frames Input Enforcement
    els.framesInput.addEventListener('input', function() {
        if (state.twitchMode) {
            const val = parseInt(this.value);
            if (val > 60) this.value = 60;
        }
    });

    // Twitch Mode Toggle
    els.twitchModeToggle.addEventListener('change', e => {
        state.twitchMode = e.target.checked;
        updateTwitchModeUI();
        // Force square if Twitch mode enabled
        if(state.twitchMode) {
            state.freeAspect = false;
            els.freeAspectToggle.checked = false;
            // Reset crop to square
            const size = Math.min(state.cropW, state.cropH);
            state.cropW = size; state.cropH = size;
            updateNavBox();
        }
    });

    // Original Size Toggle
    els.originalSizeToggle.addEventListener('change', e => {
        state.useOriginalSize = e.target.checked;
        if (state.useOriginalSize) {
            els.sizeInput.disabled = true;
            els.sizeInput.classList.add('opacity-50');
        } else {
            els.sizeInput.disabled = false;
            els.sizeInput.classList.remove('opacity-50');
        }
    });

    // Free Aspect Toggle
    els.freeAspectToggle.addEventListener('change', e => {
        state.freeAspect = e.target.checked;
        if(!state.freeAspect) {
            // Reset to square
            const size = Math.min(state.cropW, state.cropH);
            state.cropW = size; state.cropH = size;
            updateNavBox();
        }
    });

    function updateTwitchModeUI() {
        if (state.twitchMode) {
            // Twitch Mode ON
            els.sizeInput.max = 112;
            if (parseInt(els.sizeInput.value) > 112) els.sizeInput.value = 112;
            
            state.useOriginalSize = false;
            els.originalSizeToggle.checked = false;
            els.originalSizeToggle.disabled = true;
            els.originalSizeLabel.classList.add('opacity-50');
            
            els.freeAspectToggle.disabled = true;
            els.freeAspectToggle.checked = false;
            
            els.sizeInput.disabled = false;
            els.sizeInput.classList.remove('opacity-50');
            
            els.fpsInput.max = 60;
            if (parseFloat(els.fpsInput.value) > 60) {
                els.fpsInput.value = 60;
                updateConfig('fps');
            }
            
            // Frames Limit
            els.framesInput.max = 60;
            if (parseInt(els.framesInput.value) > 60) {
                els.framesInput.value = 60;
                updateConfig('frames');
            }
        } else {
            // Twitch Mode OFF
            els.sizeInput.removeAttribute('max');
            els.originalSizeToggle.disabled = false;
            els.originalSizeLabel.classList.remove('opacity-50');
            els.freeAspectToggle.disabled = false;
            els.fpsInput.removeAttribute('max');
            els.framesInput.removeAttribute('max');
        }
    }
    // Init UI
    updateTwitchModeUI();

    function handleFiles(files) {
        if(!files || !files.length) return;
        const isVideo = files[0].type.startsWith('video');
        state.mode = isVideo ? 'video' : 'image';
        if (isVideo) loadVideo(files[0]); else loadImages(files, false);
    }
    function handleMiniUpload(files) {
        if(!files || !files.length) return;
        if (state.mode === 'image' && files[0].type.startsWith('image')) loadImages(files, true);
        else handleFiles(files);
    }

    function loadVideo(file) {
        const url = URL.createObjectURL(file);
        els.navVideo.src = url; els.sourceVideo.src = url;
        els.navVideo.onloadedmetadata = () => {
            state.videoDuration = els.navVideo.duration;
            state.mediaWidth = els.navVideo.videoWidth; state.mediaHeight = els.navVideo.videoHeight;
            els.initialView.classList.add('hidden'); els.editorView.classList.remove('hidden'); els.editorView.classList.add('flex');
            
            els.navVideo.style.display = 'block'; els.navImage.style.display = 'none';
            els.videoTimelineArea.style.display = 'block'; els.imageListArea.style.display = 'none';
            els.extendFramesContainer.style.display = 'none'; els.modeBadge.innerText = "VIDEO MODE";
            
            state.fps = 30; 
            state.startTime = 0; 
            state.endTime = Math.min(state.videoDuration, 1.0);
            state.totalFrames = Math.round(state.fps * (state.endTime - state.startTime));
            
            els.fpsInput.value = 30; els.fpsSelect.value = 30;
            els.durationInput.value = (state.endTime - state.startTime).toFixed(2);
            els.framesInput.value = state.totalFrames;
            
            fitNavigatorToScreen();
            autoMaximizeCrop(); updateTimelineUI(); showToast("Video Loaded");
        };
        els.sourceVideo.currentTime = 0;
    }

    async function loadImages(files, isAppend) {
        if(!isAppend) { state.images = []; els.imageListContainer.innerHTML = ''; }
        let loadedCount = 0;
        for (let i = 0; i < files.length; i++) {
            if(!files[i].type.startsWith('image')) continue;
            const url = URL.createObjectURL(files[i]);
            state.images.push({ url: url });
            
            const div = document.createElement('div'); div.className = 'sortable-item'; div.draggable = true;
            div.innerHTML = `
                <img src="${url}">
                <div class="delete-btn" title="Remove">×</div>
                <div class="sortable-index">${state.images.length}</div>
            `;
            
            div.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteImage(div);
            });

            div.addEventListener('dragstart', function() { this.classList.add('dragging'); });
            div.addEventListener('dragend', function() { this.classList.remove('dragging'); updateImageOrder(); });
            div.addEventListener('dragover', e => e.preventDefault());
            div.addEventListener('dragenter', function() {
                const dragging = document.querySelector('.dragging');
                if(dragging && dragging !== this) {
                    const container = els.imageListContainer;
                    const children = Array.from(container.children);
                    if(children.indexOf(dragging) < children.indexOf(this)) container.insertBefore(dragging, this.nextSibling);
                    else container.insertBefore(dragging, this);
                }
            });
            div.addEventListener('click', () => { els.navImage.src = url; els.sourceImage.src = url; });
            
            els.imageListContainer.appendChild(div);
            loadedCount++;
        }
        
        if (state.images.length > 0) {
            const img = new Image(); img.src = state.images[0].url;
            await new Promise(r => img.onload = r);
            state.mediaWidth = img.naturalWidth; state.mediaHeight = img.naturalHeight;
            els.navImage.src = state.images[0].url; els.sourceImage.src = state.images[0].url;
            
            els.initialView.classList.add('hidden'); els.editorView.classList.remove('hidden'); els.editorView.classList.add('flex');
            els.navVideo.style.display = 'none'; els.navImage.style.display = 'block';
            els.videoTimelineArea.style.display = 'none'; els.imageListArea.style.display = 'block';
            els.extendFramesContainer.style.display = 'flex'; els.modeBadge.innerText = "IMAGE MODE";
            
            if(!isAppend) {
                state.fps = 30; state.totalFrames = 30;
                els.fpsInput.value = 30; els.fpsSelect.value = 30;
                els.durationInput.value = "1.00";
                els.framesInput.value = 30;
                autoMaximizeCrop();
            }
            
            if (!state.extendFrames) {
                state.totalFrames = state.images.length;
                els.framesInput.value = state.totalFrames;
                updateConfig('frames');
            }
            
            fitNavigatorToScreen();
            els.imageCountDisplay.innerText = `${state.images.length} Images`;
            showToast(`${loadedCount} Images Added`);
        }
    }
    
    function deleteImage(divElement) {
        const container = els.imageListContainer;
        if(divElement.parentNode === container) {
            container.removeChild(divElement);
        }
        updateImageOrder();
        els.imageCountDisplay.innerText = `${state.images.length} Images`;
        
        if(state.images.length === 0) {
            els.navImage.src = ''; els.sourceImage.src = '';
        } else {
            els.navImage.src = state.images[0].url; els.sourceImage.src = state.images[0].url;
        }
        
        if (!state.extendFrames && state.mode === 'image') {
            state.totalFrames = Math.max(1, state.images.length);
            els.framesInput.value = state.totalFrames;
            updateConfig('frames');
        }
    }
    
    function updateImageOrder() {
        const newImages = [];
        Array.from(els.imageListContainer.children).forEach((div, idx) => {
            const imgUrl = div.querySelector('img').src;
            newImages.push({ url: imgUrl });
            div.querySelector('.sortable-index').innerText = idx + 1;
        });
        state.images = newImages;
    }

    // --- Config Logic ---
    els.fpsInput.addEventListener('change', () => updateConfig('fps'));
    els.fpsSelect.addEventListener('change', () => { els.fpsInput.value = els.fpsSelect.value; updateConfig('fps'); });
    els.durationInput.addEventListener('change', () => updateConfig('duration'));
    els.framesInput.addEventListener('change', () => updateConfig('frames'));

    function updateConfig(source) {
        let fps = parseFloat(els.fpsInput.value) || 30;
        let duration = parseFloat(els.durationInput.value) || 1.0;
        let frames = parseInt(els.framesInput.value) || 30;

        if (fps <= 0) fps = 1;
        if (fps > 60) fps = 60;
        if (duration < 0.01) duration = 0.01;
        if (frames < 1) frames = 1;

        if (state.mode === 'image' && !state.extendFrames) {
            frames = Math.max(1, state.images.length);
            els.framesInput.value = frames;
            if (source === 'fps') {
                duration = frames / fps;
            } else if (source === 'duration') {
                fps = frames / duration;
            }
        } else {
            if (source === 'fps') {
                frames = Math.round(fps * duration);
            } else if (source === 'duration') {
                frames = Math.round(fps * duration);
                if (state.mode === 'video') {
                    const maxAllowed = state.videoDuration - state.startTime;
                    if (duration > maxAllowed) {
                        duration = maxAllowed;
                        frames = Math.round(fps * duration);
                    }
                    state.endTime = state.startTime + duration;
                    updateTimelineUI();
                }
            } else if (source === 'frames') {
                duration = frames / fps;
                if (state.mode === 'video') {
                    const maxAllowed = state.videoDuration - state.startTime;
                    if (duration > maxAllowed) {
                        duration = maxAllowed;
                        frames = Math.round(fps * duration);
                    }
                    state.endTime = state.startTime + duration;
                    updateTimelineUI();
                }
            }
        }

        // Twitch Mode Limit Check
        if (state.twitchMode && frames > 60) {
            frames = 60;
            // Recalculate duration based on limit
            duration = frames / fps;
            if (state.mode === 'video') {
                state.endTime = state.startTime + duration;
                updateTimelineUI();
            }
        }

        state.fps = fps;
        state.totalFrames = frames;
        
        els.fpsInput.value = Math.round(fps * 100) / 100;
        els.durationInput.value = duration.toFixed(2);
        els.framesInput.value = frames;
        
        if (state.mode === 'video') {
            state.maxDuration = 60 / state.fps; 
            els.maxDurationDisplay.innerText = `Max ${state.maxDuration.toFixed(1)}s (Ref)`;
        }
    }

    // --- Responsive Navigator Logic ---
    function fitNavigatorToScreen() {
        if (!state.mediaWidth || !state.mediaHeight) return;
        const areaW = els.navArea.clientWidth - 40;
        const areaH = els.navArea.clientHeight - 40;
        if (areaW <= 0 || areaH <= 0) return;

        const mediaRatio = state.mediaWidth / state.mediaHeight;
        const areaRatio = areaW / areaH;
        let finalW, finalH;

        if (areaRatio > mediaRatio) {
            finalH = areaH; finalW = finalH * mediaRatio;
        } else {
            finalW = areaW; finalH = finalW / mediaRatio;
        }
        els.navContainer.style.width = `${finalW}px`;
        els.navContainer.style.height = `${finalH}px`;
        updateNavBox();
    }
    window.addEventListener('resize', () => { fitNavigatorToScreen(); });

    function autoMaximizeCrop() {
        if (!state.mediaWidth) return;
        let size = Math.min(state.mediaWidth, state.mediaHeight);
        state.cropW = size;
        state.cropH = size;
        state.posX = (state.mediaWidth - size) / 2;
        state.posY = (state.mediaHeight - size) / 2;
        updateNavBox(); updateFilterPreview();
    }

    // --- Navigator Drag & Resize ---
    function clampPos() {
        if(!state.mediaWidth) return;
        const maxX = state.mediaWidth - state.cropW;
        const maxY = state.mediaHeight - state.cropH;
        
        state.posX = Math.max(0, Math.min(state.posX, maxX));
        state.posY = Math.max(0, Math.min(state.posY, maxY));
    }

    els.navContainer.addEventListener('mousedown', e => {
        if (e.target === els.navResizeHandle) return;
        e.preventDefault();
        state.isDraggingNav = true;
        const boxRect = els.navBox.getBoundingClientRect();
        state.dragStart = { offsetX: e.clientX - boxRect.left, offsetY: e.clientY - boxRect.top };
    });
    els.navResizeHandle.addEventListener('mousedown', e => {
        e.stopPropagation(); e.preventDefault();
        state.isResizingNav = true;
        const boxRect = els.navBox.getBoundingClientRect();
        const containerRect = els.navContainer.getBoundingClientRect();
        state.dragStart = { boxLeft: boxRect.left - containerRect.left, boxTop: boxRect.top - containerRect.top };
    });
    window.addEventListener('mouseup', () => { state.isDraggingNav = false; state.isResizingNav = false; state.isDraggingTimeline = false; });
    window.addEventListener('mousemove', e => {
        if(state.isDraggingTimeline) { handleTimelineMove(e); return; }
        if(!state.isDraggingNav && !state.isResizingNav) return;

        const navW = els.navVideo.clientWidth || els.navImage.clientWidth;
        const navH = els.navVideo.clientHeight || els.navImage.clientHeight;
        if (!navW || !navH) return;

        const ratioX = navW / state.mediaWidth;
        const ratioY = navH / state.mediaHeight;
        const containerRect = els.navContainer.getBoundingClientRect();

        if (state.isDraggingNav) {
            e.preventDefault();
            const newBoxLeft = e.clientX - containerRect.left - state.dragStart.offsetX;
            const newBoxTop = e.clientY - containerRect.top - state.dragStart.offsetY;
            
            state.posX = newBoxLeft / ratioX;
            state.posY = newBoxTop / ratioY;
            
            clampPos();
            updateNavBox(); updateFilterPreview();
        }
        if (state.isResizingNav) {
            e.preventDefault();
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;
            
            // Calculate new size in screen pixels
            let newBoxW = mouseX - state.dragStart.boxLeft;
            let newBoxH = mouseY - state.dragStart.boxTop;
            
            newBoxW = Math.max(20, newBoxW);
            newBoxH = Math.max(20, newBoxH);
            
            // Convert to image pixels
            let newCropW = newBoxW / ratioX;
            let newCropH = newBoxH / ratioY;
            
            // Aspect Ratio Logic
            if (!state.freeAspect) {
                // Force Square (use larger dimension or X)
                const size = Math.max(newCropW, newCropH);
                newCropW = size;
                newCropH = size;
            }
            
            // Limit max size to image boundary
            newCropW = Math.min(newCropW, state.mediaWidth - state.posX);
            newCropH = Math.min(newCropH, state.mediaHeight - state.posY);
            
            if (!state.freeAspect) {
                // Re-clamp for square if hit boundary
                const size = Math.min(newCropW, newCropH);
                newCropW = size; newCropH = size;
            }
            
            state.cropW = newCropW;
            state.cropH = newCropH;
            
            updateNavBox(); updateFilterPreview();
        }
    });

    function updateNavBox() {
        if(!state.mediaWidth) return;
        const navW = els.navVideo.clientWidth || els.navImage.clientWidth; const navH = els.navVideo.clientHeight || els.navImage.clientHeight;
        if(!navW) return;
        const ratioX = navW / state.mediaWidth; const ratioY = navH / state.mediaHeight;
        
        const boxLeft = state.posX * ratioX;
        const boxTop = state.posY * ratioY;
        const boxW = state.cropW * ratioX;
        const boxH = state.cropH * ratioY;
        
        els.navBox.style.left = `${boxLeft}px`; els.navBox.style.top = `${boxTop}px`;
        els.navBox.style.width = `${boxW}px`; els.navBox.style.height = `${boxH}px`;
    }

    function updateFilterPreview() {
        const f = `brightness(${state.filters.brightness}%) contrast(${state.filters.contrast}%) saturate(${state.filters.saturate}%)`;
        if (state.mode === 'video') els.sourceVideo.style.filter = f; else els.sourceImage.style.filter = f;
        els.navVideo.style.filter = f; els.navImage.style.filter = f;
    }

    // Sliders
    const bindSlider = (el, key) => el.addEventListener('input', e => { state.filters[key] = e.target.value; updateFilterPreview(); });
    bindSlider(els.brightnessSlider, 'brightness'); bindSlider(els.contrastSlider, 'contrast'); bindSlider(els.saturateSlider, 'saturate');

    // Timeline
    els.timeline.addEventListener('mousedown', e => {
        if(state.mode !== 'video') return;
        state.isDraggingTimeline = true;
        const rect = els.timeline.getBoundingClientRect();
        const clickPct = ((e.clientX - rect.left) / rect.width) * 100;
        
        if(e.target.classList.contains('handle-left')) {
            state.dragStart = { mode: 'resize-left', startPct: (state.startTime / state.videoDuration) * 100, endPct: (state.endTime / state.videoDuration) * 100, x: e.clientX };
        } else if(e.target.classList.contains('handle-right')) {
            state.dragStart = { mode: 'resize-right', startPct: (state.startTime / state.videoDuration) * 100, endPct: (state.endTime / state.videoDuration) * 100, x: e.clientX };
        } else if(e.target.classList.contains('timeline-selection') || e.target.closest('.timeline-selection')) {
            state.dragStart = { mode: 'move', startPct: (state.startTime / state.videoDuration) * 100, endPct: (state.endTime / state.videoDuration) * 100, x: e.clientX };
        } else {
            // Create new selection
            const time = (clickPct / 100) * state.videoDuration;
            state.startTime = time;
            state.endTime = time;
            state.dragStart = { mode: 'create', startX: e.clientX, startTime: time };
            updateTimelineUI();
            els.sourceVideo.currentTime = time;
        }
    });

    function handleTimelineMove(e) {
        const rect = els.timeline.getBoundingClientRect();
        
        if (state.dragStart.mode === 'create') {
            const currentPct = ((e.clientX - rect.left) / rect.width);
            const currentTime = Math.max(0, Math.min(state.videoDuration, currentPct * state.videoDuration));
            state.startTime = Math.min(state.dragStart.startTime, currentTime);
            state.endTime = Math.max(state.dragStart.startTime, currentTime);
            
            const newDuration = state.endTime - state.startTime;
            els.durationInput.value = newDuration.toFixed(2);
            state.totalFrames = Math.round(state.fps * newDuration);
            els.framesInput.value = state.totalFrames;
            
            updateTimelineUI();
            return;
        }

        const deltaPct = ((e.clientX - state.dragStart.x) / rect.width) * 100;
        let newStart = state.dragStart.startPct; let newEnd = state.dragStart.endPct;

        if (state.dragStart.mode === 'resize-left') {
            newStart += deltaPct; newStart = Math.min(newStart, newEnd - 0.5); newStart = Math.max(0, newStart);
        } else if (state.dragStart.mode === 'resize-right') {
            newEnd += deltaPct; newEnd = Math.max(newEnd, newStart + 0.5); newEnd = Math.min(100, newEnd);
        } else if (state.dragStart.mode === 'move') { 
            const width = newEnd - newStart; newStart += deltaPct; newEnd = newStart + width;
            if(newStart < 0) { newStart = 0; newEnd = width; } if(newEnd > 100) { newEnd = 100; newStart = 100 - width; }
        }
        
        state.startTime = (newStart / 100) * state.videoDuration;
        state.endTime = (newEnd / 100) * state.videoDuration;
        updateTimelineUI(); els.sourceVideo.currentTime = state.startTime;
        
        const newDuration = state.endTime - state.startTime;
        els.durationInput.value = newDuration.toFixed(2);
        state.totalFrames = Math.round(state.fps * newDuration);
        els.framesInput.value = state.totalFrames;
    }
    function updateTimelineUI() {
        const startPct = (state.startTime / state.videoDuration) * 100;
        const endPct = (state.endTime / state.videoDuration) * 100;
        els.timelineSelection.style.left = `${startPct}%`; els.timelineSelection.style.width = `${endPct - startPct}%`;
        els.timeDisplay.innerText = `${state.startTime.toFixed(1)}s - ${state.endTime.toFixed(1)}s`;
    }

    // Output Size Helper
    function getOutputDimensions() {
        if (state.useOriginalSize && !state.twitchMode) {
            return { width: Math.round(state.cropW), height: Math.round(state.cropH) };
        }
        
        // User input size (treated as max dimension or width)
        let inputSize = parseInt(els.sizeInput.value) || 112;
        if (state.twitchMode && inputSize > 112) inputSize = 112;
        
        if (state.twitchMode || !state.freeAspect) {
            // Square
            return { width: inputSize, height: inputSize };
        } else {
            // Free Aspect: Maintain ratio based on inputSize as the larger dimension
            const ratio = state.cropW / state.cropH;
            let w, h;
            if (ratio >= 1) {
                // Landscape
                w = inputSize;
                h = Math.round(inputSize / ratio);
            } else {
                // Portrait
                w = Math.round(inputSize * ratio);
                h = inputSize;
            }
            // Ensure at least 1px
            return { width: Math.max(1, w), height: Math.max(1, h) };
        }
    }

    // Preview
    els.qualitySelect.addEventListener('change', previewQuality);
    async function previewQuality() {
        if(!workerBlobURL) return;
        els.previewLoading.style.display = 'flex'; els.qualityPreviewImage.style.display = 'none';
        if(state.isPlayingLoop) togglePlayLoop();
        if(state.mode === 'video') els.sourceVideo.pause();

        try {
            const quality = parseInt(els.qualitySelect.value);
            const dims = getOutputDimensions();
            
            const gif = new GIF({ workers: 4, quality: quality, width: dims.width, height: dims.height, workerScript: workerBlobURL, dither: false });
            const canvas = document.createElement('canvas'); canvas.width = dims.width; canvas.height = dims.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false });
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            ctx.filter = `brightness(${state.filters.brightness}%) contrast(${state.filters.contrast}%) saturate(${state.filters.saturate}%)`;
            
            const sx = state.posX;
            const sy = state.posY;
            const sw = state.cropW;
            const sh = state.cropH;
            
            ctx.fillStyle = '#000'; ctx.fillRect(0,0, dims.width, dims.height);
            if(state.mode === 'video') ctx.drawImage(els.sourceVideo, sx, sy, sw, sh, 0, 0, dims.width, dims.height);
            else ctx.drawImage(els.sourceImage, sx, sy, sw, sh, 0, 0, dims.width, dims.height);
            
            gif.addFrame(ctx, { copy: true });
            gif.on('finished', blob => resolve(blob));
            gif.render();
        } catch(e) { els.previewLoading.style.display = 'none'; }
    }
    function clearQualityPreview() { els.qualityPreviewImage.style.display = 'none'; }
    els.navContainer.addEventListener('mousedown', clearQualityPreview);

    // Play Loop
    els.playLoopBtn.addEventListener('click', togglePlayLoop);
    function togglePlayLoop() {
        if (state.isPlayingLoop) {
            state.isPlayingLoop = false; cancelAnimationFrame(state.animationFrameId);
            if(state.mode === 'video') { els.sourceVideo.pause(); els.navVideo.pause(); }
            els.playIcon.innerHTML = '<path d="M8 5v14l11-7z"/>'; els.playLoopBtn.classList.replace('bg-[#9146FF]', 'bg-[#27272a]');
        } else {
            clearQualityPreview(); state.isPlayingLoop = true;
            els.playIcon.innerHTML = '<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>'; els.playLoopBtn.classList.replace('bg-[#27272a]', 'bg-[#9146FF]');
            if(state.mode === 'video') { 
                els.sourceVideo.currentTime = state.startTime; els.sourceVideo.play(); 
                els.navVideo.currentTime = state.startTime; els.navVideo.play(); // Sync Nav
                loopVideo(); 
            }
            else { state.loopStartTime = null; loopImage(); }
        }
    }
    function loopVideo() {
        if(!state.isPlayingLoop) return;
        if(els.sourceVideo.currentTime >= state.endTime) {
            els.sourceVideo.currentTime = state.startTime;
            els.navVideo.currentTime = state.startTime;
        }
        if(Math.abs(els.navVideo.currentTime - els.sourceVideo.currentTime) > 0.2) {
            els.navVideo.currentTime = els.sourceVideo.currentTime;
        }
        const pct = (els.sourceVideo.currentTime / state.videoDuration) * 100;
        els.playhead.style.left = `${pct}%`;
        requestAnimationFrame(loopVideo);
    }
    function loopImage(timestamp) {
        if(!state.isPlayingLoop) return;
        if(!timestamp) timestamp = performance.now();
        if(!state.loopStartTime) state.loopStartTime = timestamp;
        
        const elapsed = timestamp - state.loopStartTime;
        const frameDuration = 1000 / state.fps;
        let currentFrame = Math.floor(elapsed / frameDuration) % state.totalFrames;
        let index = Math.floor(currentFrame * (state.images.length / state.totalFrames));
        index = Math.min(index, state.images.length - 1);
        
        if(state.images[index]) {
            els.sourceImage.src = state.images[index].url;
            els.navImage.src = state.images[index].url;
        }
        state.animationFrameId = requestAnimationFrame(loopImage);
    }

    // Generate
    els.generateBtn.addEventListener('click', async () => {
        if(!workerBlobURL) return showToast("Initializing...");
        if(state.isPlayingLoop) togglePlayLoop();
        clearQualityPreview();
        els.generateBtn.disabled = true; els.progressContainer.classList.remove('hidden');

        try {
            const quality = parseInt(els.qualitySelect.value);
            const dims = getOutputDimensions();
            
            const gif = new GIF({ workers: 4, quality: quality, width: dims.width, height: dims.height, workerScript: workerBlobURL });
            const canvas = document.createElement('canvas'); canvas.width = dims.width; canvas.height = dims.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false });
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            ctx.filter = `brightness(${state.filters.brightness}%) contrast(${state.filters.contrast}%) saturate(${state.filters.saturate}%)`;
            
            const sx = state.posX;
            const sy = state.posY;
            const sw = state.cropW;
            const sh = state.cropH;
            
            if(state.mode === 'video') {
                const step = 1 / state.fps; const duration = state.endTime - state.startTime;
                let t = state.startTime;
                let frameCount = 0;
                const process = async () => {
                    if(t >= state.endTime || frameCount >= state.totalFrames) { gif.render(); return; }
                    els.sourceVideo.currentTime = t;
                    await new Promise(r => { const h=()=>{els.sourceVideo.removeEventListener('seeked',h);r()}; els.sourceVideo.addEventListener('seeked',h); });
                    ctx.fillStyle = '#000'; ctx.fillRect(0,0, dims.width, dims.height);
                    ctx.drawImage(els.sourceVideo, sx, sy, sw, sh, 0, 0, dims.width, dims.height);
                    gif.addFrame(ctx, { copy: true, delay: step * 1000 });
                    els.progressBar.style.width = ((t-state.startTime)/duration*100)+'%';
                    t += step; frameCount++; setTimeout(process, 0);
                };
                process();
            } else {
                const delay = 1000 / state.fps;
                const total = state.totalFrames;
                for(let i=0; i<total; i++) {
                    let idx = Math.floor(i * (state.images.length / total));
                    idx = Math.min(idx, state.images.length-1);
                    const img = new Image(); img.src = state.images[idx].url;
                    await new Promise(r => img.onload = r);
                    ctx.fillStyle = '#000'; ctx.fillRect(0,0, dims.width, dims.height);
                    ctx.drawImage(img, sx, sy, sw, sh, 0, 0, dims.width, dims.height);
                    gif.addFrame(ctx, { copy: true, delay: delay });
                    els.progressBar.style.width = ((i/total)*100)+'%';
                }
                gif.render();
            }
            gif.on('finished', blob => {
                const url = URL.createObjectURL(blob);
                const isOverSize = blob.size > 1024 * 1024;
                const sizeText = (blob.size / 1024).toFixed(1) + 'KB';
                const sizeClass = isOverSize ? 'text-red-500 font-bold' : 'text-gray-500';
                const btnClass = isOverSize ? 'bg-red-600 hover:bg-red-700' : 'bg-[#9146FF] hover:bg-[#772ce8]';
                const btnText = isOverSize ? 'OVER 1MB' : 'DL';
                
                const div = document.createElement('div');
                div.className = "flex items-center gap-3 bg-[#1f1f23] p-2 rounded-lg border border-[#333] mb-2";
                div.innerHTML = `<img src="${url}" class="w-10 h-10 rounded"><div class="flex-1 min-w-0"><div class="text-xs font-bold text-white">Stamp (${dims.width}x${dims.height})</div><div class="text-[10px] ${sizeClass}">${sizeText}</div></div><a href="${url}" download="stamp.gif" class="text-xs ${btnClass} px-2 py-1 rounded text-white text-center min-w-[50px]">${btnText}</a>`;
                els.resultList.insertBefore(div, els.resultList.firstChild);
                els.generateBtn.disabled = false; els.progressContainer.classList.add('hidden');
                if(isOverSize) showToast("Warning: File size > 1MB");
                else showToast("Generated!");
            });
        } catch(e) { els.generateBtn.disabled = false; console.error(e); }
    });

    function showToast(msg) {
        const t = document.getElementById('toast'); t.innerText = msg; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }
</script>
</body>
</html>
